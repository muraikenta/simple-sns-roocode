# アーキテクチャドキュメント

## レイヤードアーキテクチャの導入

このプロジェクトではレイヤードアーキテクチャを導入し、システムの各層の責務を明確に分離しています。これにより、メンテナンス性と拡張性を高め、テストもしやすくなります。

### 基本構造

```
src/
├── components/    # UIコンポーネント
├── contexts/      # Reactコンテキスト
├── lib/           # ユーティリティとライブラリ
├── pages/         # ページコンポーネント
├── repositories/  # データアクセス層
└── types/         # 型定義
```

### アーキテクチャの各層

1. **プレゼンテーション層**
   - `components/` と `pages/`
   - ユーザーインターフェースを担当
   - ユーザーの入力を受け取り、ユーザーに情報を表示する

2. **アプリケーション層**
   - コンポーネントやコンテキスト内のロジック部分
   - ユーザーの操作を実行可能なアクションに変換
   - ドメインオブジェクトを操作し、必要に応じてリポジトリを利用

3. **データアクセス層**
   - `repositories/`
   - データベース（Supabase）とのやりとりを担当
   - CRUD操作を抽象化して提供

### リポジトリパターン

リポジトリパターンを採用し、データアクセスのロジックをリポジトリクラスに集約しています。

#### 特徴

- インターフェースとその実装を分離
- 差し替え可能で、テストが容易
- アプリケーションロジックがデータアクセスの詳細を知る必要がない

#### 構造

```
repositories/
├── factory.ts                 # リポジトリファクトリ
├── interfaces.ts              # リポジトリインターフェース
└── supabase/                  # Supabase実装
    ├── AuthRepository.ts      # 認証リポジトリ実装
    ├── PostRepository.ts      # 投稿リポジトリ実装
    ├── StorageRepository.ts   # ストレージリポジトリ実装
    └── UserRepository.ts      # ユーザーリポジトリ実装
```

### リポジトリの定義

各リポジトリはデータアクセスの特定の側面を担当します：

1. **UserRepository**
   - ユーザー情報のCRUD操作

2. **PostRepository**
   - 投稿のCRUD操作

3. **AuthRepository**
   - 認証関連の操作
   - サインアップ、サインイン、サインアウトなど

4. **StorageRepository**
   - ファイルストレージ操作
   - 画像のアップロード、URL取得など

### ファクトリパターン

リポジトリのインスタンスはファクトリを通じて取得します：

```typescript
// 使用例
const userRepository = RepositoryFactory.getUserRepository();
const posts = await userRepository.getUserById("user-id");
```

このパターンのメリット：

- 依存関係の注入が簡素化される
- テスト時のモック置き換えが容易
- シングルトンとしてリポジトリが管理される

### 拡張性

この構造は将来的に以下のような拡張が容易です：

1. **別のデータストアへの移行**
   - 新しいリポジトリ実装を作成するだけで対応可能

2. **キャッシュレイヤーの追加**
   - リポジトリ内部にキャッシュロジックを追加できる

3. **トランザクション管理の追加**
   - Unit of Workパターンを導入可能

### テスト戦略

リポジトリを抽象化することで、テストが容易になります：

```typescript
// テスト例
const mockUserRepo = {
  getUserById: vi.fn().mockResolvedValue({ id: "test-id", name: "Test User" }),
};
RepositoryFactory.setUserRepository(mockUserRepo);
```

## 今後の展望

- **サービス層の導入**：複雑なビジネスロジックをサービスクラスに分離
- **状態管理の改善**：Reduxなどのグローバル状態管理の導入
- **ドメインモデルの強化**：より洗練されたドメインモデルの作成